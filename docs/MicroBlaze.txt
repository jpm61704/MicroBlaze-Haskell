-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Short description of your package
--   
--   Please see the README on Github at
--   <a>https://github.com/githubuser/MicroBlaze#readme</a>
@package MicroBlaze
@version 0.1.0.0

module Parsing
data Parser a
P :: (String -> [(a, String)]) -> Parser a
failure :: Parser a
item :: Parser Char
parse :: Parser a -> String -> [(a, String)]
(+++) :: Parser a -> Parser a -> Parser a
infixr 5 +++
sat :: (Char -> Bool) -> Parser Char
digit :: Parser Char
lower :: Parser Char
upper :: Parser Char
letter :: Parser Char
alphanum :: Parser Char
char :: Char -> Parser Char
string :: String -> Parser String
many :: Parser a -> Parser [a]
many1 :: Parser a -> Parser [a]
ident :: Parser String
nat :: Parser Int
int :: Parser Int
space :: Parser ()
token :: Parser a -> Parser a
identifier :: Parser String
natural :: Parser Int
integer :: Parser Int
symbol :: String -> Parser String
instance GHC.Base.Functor Parsing.Parser
instance GHC.Base.Alternative Parsing.Parser
instance GHC.Base.Applicative Parsing.Parser
instance GHC.Base.Monad Parsing.Parser
instance GHC.Base.MonadPlus Parsing.Parser


module MachineState.MachineStatusRegister
data RMSR

-- | a zero-initialized (All False) MSR
emptyRMSR :: RMSR

-- | gets the status register in the form of a 32-bit word
getMSRWord :: RMSR -> Word32

-- | sets the status register from a 32-bit MSR word
setMSRWord :: Word32 -> RMSR

-- | Various status flags in the Machine State Register
data MachineStatusBit
CarryCopy :: MachineStatusBit
DataCacheEnable :: MachineStatusBit
DivisionByZero :: MachineStatusBit
InstructionCacheEnable :: MachineStatusBit
FSLError :: MachineStatusBit
BreakInProgress :: MachineStatusBit
Carry :: MachineStatusBit
InterruptEnable :: MachineStatusBit
BuslockEnable :: MachineStatusBit
DelayEnable :: MachineStatusBit

-- | Get the status of a specified flag
getStatus :: MachineStatusBit -> RMSR -> Bool

-- | sets the machine status bit indicated to the desired boolean value
setStatus :: MachineStatusBit -> Bool -> RMSR -> RMSR
instance GHC.Show.Show MachineState.MachineStatusRegister.MachineStatusBit


-- | A resumption monad transformer, based on the formulation in the
--   article <a>Cheap (But Functional) Threads</a> by William L. Harrison
--   and Adam Procter.
module Control.Monad.Resumption

-- | Resumption monad transformer.
newtype ResT m a
ResT :: m (Either a (ResT m a)) -> ResT m a
[deResT] :: ResT m a -> m (Either a (ResT m a))

-- | Runs a resumptive computation to exhaustion, producing its final
--   return value.
runResT :: (Monad m) => ResT m a -> m a

-- | Waits until the next tick.
tick :: Monad m => ResT m ()
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Resumption.ResT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Resumption.ResT
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Monad.Resumption.ResT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Resumption.ResT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Resumption.ResT m)
instance Control.Monad.Morph.MFunctor Control.Monad.Resumption.ResT


-- | A reactive resumption monad transformer, based on the formulation in
--   the article <a>Cheap (But Functional) Threads</a> by William L.
--   Harrison and Adam Procter.
module Control.Monad.Resumption.Reactive

-- | Reactive resumption monad transformer.
newtype ReacT input output m a
ReacT :: m (Either a (output, input -> ReacT input output m a)) -> ReacT input output m a
[deReacT] :: ReacT input output m a -> m (Either a (output, input -> ReacT input output m a))

-- | Outputs its argument, then waits for the next input and returns it.
signal :: Monad m => output -> ReacT input output m input

-- | Tennis operator.
(<~>) :: Monad m => ReacT i o m a -> ReacT o i m b -> ResT m (Either a b)

-- | A basic runner function. Provide the ReacT and a handler in the
--   underlying monad to run.
runReacT :: Monad m => ReacT input output m a -> (output -> m input) -> m a
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Resumption.Reactive.ReacT input output m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Resumption.Reactive.ReacT input output)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Monad.Resumption.Reactive.ReacT input output m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Resumption.Reactive.ReacT input output m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Resumption.Reactive.ReacT input output m)
instance Control.Monad.Morph.MFunctor (Control.Monad.Resumption.Reactive.ReacT i o)

module Control.Monad.Resumption.Connectors

-- | The parallel operator for combining computations in ReacT that share
--   the same underlying monad and halting types. No guarantees are given
--   to which device's halting message will be seen by a handler.
(<||>) :: (Monad m) => ReacT i1 o1 m a -> ReacT i2 o2 m a -> ReacT (i1, i2) (o1, o2) m a
refoldT :: forall o1 o2 i1 i2 m a. Monad m => (o1 -> o2) -> (o1 -> i2 -> Maybe i1) -> ReacT i1 o1 m a -> ReacT i2 o2 m a

-- | The refold operator changes the output and input types of a reactive
--   resumption
refold :: (Monad m) => (o1 -> o2) -> (o1 -> i2 -> i1) -> ReacT i1 o1 m a -> ReacT i2 o2 m a

-- | Chains two reactive resumptions together in a pipelined fashioned.
--   That is, inputs and outputs are passed along between devices
--   "tickwise".
pipeline :: (Monad m) => ReacT i z m a -> ReacT z o m a -> ReacT i o m a

module Boilerplate.Machines

-- | A machine of inert(stateless) registers
data Machine l sl r
machine :: (FiniteBits r) => Int -> [String] -> Machine String String r

-- | A register bank with labels l and registers r
data RegisterBank l r

-- | Creates a new register bank using a generator functions to produce
--   label l
newRegisterBank :: (FiniteBits r, Ord l) => Int -> (Int -> l) -> RegisterBank l r

-- | produces a register bank with numeric labels proceeded by the
--   character <tt>r</tt>. For example the first register is "r0" Important
--   to note that this produces a strange order from labels being Strings
standardRegisterBank :: (FiniteBits r) => Int -> RegisterBank String r
type SpecialRegisters sl r = RegisterBank sl r
specialFromList :: (FiniteBits r, Ord l) => [l] -> SpecialRegisters l r
mb :: Machine String String Word32
instance (GHC.Show.Show sl, GHC.Show.Show l, GHC.Show.Show r) => GHC.Show.Show (Boilerplate.Machines.Machine l sl r)
instance (GHC.Show.Show r, GHC.Show.Show l) => GHC.Show.Show (Boilerplate.Machines.RegisterBank l r)

module Boilerplate.Instruction
type Name = String
type Size = Word

-- | This type is used for defining arguments and their sizes for use as
--   instruction codes
data Arguments
Register :: Name -> Arguments -> Arguments
Immediate :: Arguments -> Arguments
END :: Arguments
data InstructionType
InsType :: Arguments -> InstructionType
typeA :: InstructionType
typeB :: InstructionType
imm :: Arguments
ra :: Arguments
rb :: Arguments
rd :: Arguments
instance GHC.Read.Read Boilerplate.Instruction.Arguments
instance GHC.Show.Show Boilerplate.Instruction.Arguments
instance GHC.Base.Monoid Boilerplate.Instruction.Arguments
instance Data.Semigroup.Semigroup Boilerplate.Instruction.Arguments


module Boilerplate

-- | Standard Bit Datatype Supporting functions can be found in
--   <a>Boilerplate.Bit</a>
data Bit
C :: Bit
S :: Bit

-- | show instance of Bit displays bits as 1 and 0

-- | Standard Byte defintion Supporting functions can be found in
--   <a>Boilerplate.W8</a>
data W8
W8 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> W8

-- | 16-bit data
data W16
W16 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> W16

-- | 32-bit data Supporting functions can be found in
--   <a>Boilerplate.W32</a>
data W32
W32 :: W8 -> W8 -> W8 -> W8 -> W32

-- | 5-bit data
data W5
W5 :: Bit -> Bit -> Bit -> Bit -> Bit -> W5

-- | 6-bit data
data W6
W6 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> W6

-- | 11-bit data
data W11
W11 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> W11
maybeSignExtend :: (Integral a, Integral b, FiniteBits a, FiniteBits b) => a -> Maybe b
showFiniteBits :: (FiniteBits a) => a -> String
instance GHC.Show.Show Boilerplate.W11
instance GHC.Show.Show Boilerplate.W6
instance GHC.Show.Show Boilerplate.W5
instance GHC.Show.Show Boilerplate.W16
instance GHC.Show.Show Boilerplate.Bit
instance GHC.Show.Show Boilerplate.W8
instance GHC.Show.Show Boilerplate.W32


module Boilerplate.Bit

-- | bit negation <tt> not S = C not C = S </tt>
not :: Bit -> Bit

-- | equality
(==) :: Bit -> Bit -> Bit

-- | logical AND
and :: Bit -> Bit -> Bit

-- | logical OR
or :: Bit -> Bit -> Bit

-- | logical exclusive OR
xor :: Bit -> Bit -> Bit

-- | Binary additon with carries
plus :: Bit -> Bit -> Bit -> (Bit, Bit)

-- | Binary subtraction with carries
minus :: Bit -> Bit -> Bit -> (Bit, Bit)
toInteger :: Bit -> Int


module Boilerplate.W8

-- | zero-byte (00000000)
zero :: W8

-- | one-byte (00000001)
one :: W8

-- | logical not
not :: W8 -> W8

-- | logical and
and :: W8 -> W8 -> W8

-- | logical or
or :: W8 -> W8 -> W8

-- | logical exclusive or
xor :: W8 -> W8 -> W8

-- | logical equality (as opposed to bitwise)
(==) :: W8 -> W8 -> Bit

-- | left rotation
rotateLeft :: W8 -> W8

-- | right rotation
rotateRight :: W8 -> W8

-- | left shift with carry
shiftLeft :: W8 -> Bit -> (Bit, W8)

-- | right shift with carry
shiftRight :: W8 -> Bit -> (Bit, W8)

-- | most significant bit of byte
--   
--   also is the sign-bit
mostSignificantBit :: W8 -> Bit

-- | least significant bit of byte
leastSignificantBit :: W8 -> Bit

-- | addition with carry
add :: W8 -> W8 -> Bit -> (Bit, W8)

-- | subtraction with carry
subtract :: W8 -> W8 -> Bit -> (Bit, W8)

-- | two's complement negation
negative :: W8 -> W8

-- | tests negativity
isNegative :: W8 -> Bit
arithmeticShiftRight :: W8 -> Bit -> (Bit, W8)
logicalShiftRight :: W8 -> (Bit, W8)
toInteger :: W8 -> Int
fromInteger :: Int -> W8

module Boilerplate.W16
fromInteger :: Int -> W16


module Boilerplate.W32

-- | zero value (00000000 00000000 00000000 00000000)
zero :: W32

-- | one value (00000000 00000000 00000000 00000001)
one :: W32
four :: W32

-- | Logical AND
and :: W32 -> W32 -> W32

-- | Logical OR
or :: W32 -> W32 -> W32

-- | Logical NOT
not :: W32 -> W32

-- | equality
(==) :: W32 -> W32 -> Bit
xor :: W32 -> W32 -> W32

-- | two's complement 16-bit sign extension
signExtendW16 :: W16 -> W32

-- | unsigned 16-bit extension
unsignedExtendW16 :: W16 -> W32

-- | two's complement byte sign extension
signExtendW8 :: W8 -> W32

-- | unsigned byte extension
unsignedExtendW8 :: W8 -> W32

-- | back-extends 16-bit data (useful for certain register operations)
--   
--   example : 1010 0011 -&gt; 1010 0011 0000 0000
backExtendW16 :: W16 -> W32

-- | the least significant byte
leastSignificantByte :: W32 -> W8

-- | the least significat hald-word
leastSignificantHalfWord :: W32 -> W16

-- | addition with carries
add :: W32 -> W32 -> Bit -> (Bit, W32)

-- | subtraction with carries
subtract :: W32 -> W32 -> Bit -> (Bit, W32)

-- | subtraction-based comparison with sign-preservation
signedCompare :: W32 -> W32 -> W32

-- | unsigned subtraction comparison
unsignedCompare :: W32 -> W32 -> W32

-- | test if value is negative under two's complement
isNegative :: W32 -> Bit

-- | test if a value is positive or zero under two's complement
isPositive :: W32 -> Bit

-- | test if a value is zero
isZero :: W32 -> Bit

-- | test if a value is greater than zero under two's complement
greaterThanZero :: W32 -> Bit

-- | test if a value is less than or equal to zero under two's complement
lessThanOrEqualToZero :: W32 -> Bit

-- | reverse subtraction
--   
--   rb + not(ra) + carry
reverseSubtraction :: W32 -> W32 -> Bit -> (Bit, W32)
arithmeticShiftRight :: W32 -> Bit -> (Bit, W32)
logicalShiftRight :: W32 -> (Bit, W32)
toInteger :: W32 -> Int
fromInteger :: Int -> W32


module InsSet

-- | Possible data sizes
data MBSize
ByteSize :: MBSize
HalfWordSize :: MBSize
WordSize :: MBSize

-- | All user-accesible general-purpose registers
data MBReg

-- | Dedicated, Value 0
R0 :: MBReg

-- | Dedicated, Stack Pointer
R1 :: MBReg

-- | Dedicated, Read-only small data area anchor
R2 :: MBReg

-- | Volatile, Return Value
R3 :: MBReg

-- | Volatile, Return Value
R4 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R5 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R6 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R7 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R8 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R9 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R10 :: MBReg

-- | Volatile, Temporary
R11 :: MBReg

-- | Volatile, Temporary
R12 :: MBReg

-- | Dedicated, Read-write small data area anchor
R13 :: MBReg

-- | Dedicated, Return address for Interrupt
R14 :: MBReg

-- | Dedicated, Return address for Sub-routine
R15 :: MBReg

-- | Dedicated, Return address for Trap (Debugger)
R16 :: MBReg

-- | Dedicated, Return address for Exceptions
R17 :: MBReg

-- | Dedicated, Reserved for assembler, used for Imm instruction
R18 :: MBReg

-- | Non-volatile, must be saved across function calls
R19 :: MBReg

-- | Non-volatile, must be saved across function calls
R20 :: MBReg

-- | Non-volatile, must be saved across function calls
R21 :: MBReg

-- | Non-volatile, must be saved across function calls
R22 :: MBReg

-- | Non-volatile, must be saved across function calls
R23 :: MBReg

-- | Non-volatile, must be saved across function calls
R24 :: MBReg

-- | Non-volatile, must be saved across function calls
R25 :: MBReg

-- | Non-volatile, must be saved across function calls
R26 :: MBReg

-- | Non-volatile, must be saved across function calls
R27 :: MBReg

-- | Non-volatile, must be saved across function calls
R28 :: MBReg

-- | Non-volatile, must be saved across function calls
R29 :: MBReg

-- | Non-volatile, must be saved across function calls
R30 :: MBReg

-- | Non-volatile, must be saved across function calls
R31 :: MBReg

-- | Special Purpose Registers
data MBSReg

-- | Program Counter
RPC :: MBSReg

-- | Machine Status Register
MSR :: MBSReg

-- | The MicroBlaze Instruction Set
data Ins
Add :: MBReg -> MBReg -> MBReg -> Ins
Addc :: MBReg -> MBReg -> MBReg -> Ins
Addk :: MBReg -> MBReg -> MBReg -> Ins
Addkc :: MBReg -> MBReg -> MBReg -> Ins
Addi :: MBReg -> MBReg -> Word16 -> Ins
Addic :: MBReg -> MBReg -> Word16 -> Ins
Addik :: MBReg -> MBReg -> Word16 -> Ins
Addikc :: MBReg -> MBReg -> Word16 -> Ins
And :: MBReg -> MBReg -> MBReg -> Ins
Andi :: MBReg -> MBReg -> Word16 -> Ins
Andn :: MBReg -> MBReg -> MBReg -> Ins
Andni :: MBReg -> MBReg -> Word16 -> Ins
Beq :: MBReg -> MBReg -> Ins
Beqd :: MBReg -> MBReg -> Ins
Beqi :: MBReg -> Word16 -> Ins
Beqid :: MBReg -> Word16 -> Ins
Bge :: MBReg -> MBReg -> Ins
Bged :: MBReg -> MBReg -> Ins
Bgei :: MBReg -> Word16 -> Ins
Bgeid :: MBReg -> Word16 -> Ins
Bgt :: MBReg -> MBReg -> Ins
Bgtd :: MBReg -> MBReg -> Ins
Bgti :: MBReg -> Word16 -> Ins
Bgtid :: MBReg -> Word16 -> Ins
Ble :: MBReg -> MBReg -> Ins
Bled :: MBReg -> MBReg -> Ins
Blei :: MBReg -> Word16 -> Ins
Bleid :: MBReg -> Word16 -> Ins
Blt :: MBReg -> MBReg -> Ins
Bltd :: MBReg -> MBReg -> Ins
Blti :: MBReg -> Word16 -> Ins
Bltid :: MBReg -> Word16 -> Ins
Bne :: MBReg -> MBReg -> Ins
Bned :: MBReg -> MBReg -> Ins
Bnei :: MBReg -> Word16 -> Ins
Bneid :: MBReg -> Word16 -> Ins
Br :: MBReg -> Ins
Bra :: MBReg -> Ins
Brd :: MBReg -> Ins
Brad :: MBReg -> Ins
Brld :: MBReg -> MBReg -> Ins
Brald :: MBReg -> MBReg -> Ins
Bri :: Word16 -> Ins
Brai :: Word16 -> Ins
Brid :: Word16 -> Ins
Braid :: Word16 -> Ins
Brlid :: MBReg -> Word16 -> Ins
Bralid :: MBReg -> Word16 -> Ins
Brk :: MBReg -> MBReg -> Ins
Brki :: MBReg -> Word16 -> Ins
Bsrl :: MBReg -> MBReg -> MBReg -> Ins
Bsra :: MBReg -> MBReg -> MBReg -> Ins
Bsll :: MBReg -> MBReg -> MBReg -> Ins
Bsrli :: MBReg -> MBReg -> Word16 -> Ins
Bsrai :: MBReg -> MBReg -> Word16 -> Ins
Bslli :: MBReg -> MBReg -> Word16 -> Ins
Cmp :: MBReg -> MBReg -> MBReg -> Ins
Cmpu :: MBReg -> MBReg -> MBReg -> Ins
Get :: MBReg -> Int -> Ins
Nget :: MBReg -> Int -> Ins
Cget :: MBReg -> Int -> Ins
Ncget :: MBReg -> Int -> Ins
Idiv :: MBReg -> MBReg -> MBReg -> Ins
Idivu :: MBReg -> MBReg -> MBReg -> Ins
Imm :: Word16 -> Ins
Lbu :: MBReg -> MBReg -> MBReg -> Ins
Lbui :: MBReg -> MBReg -> Word16 -> Ins
Lhu :: MBReg -> MBReg -> MBReg -> Ins
Lhui :: MBReg -> MBReg -> Word16 -> Ins
Lw :: MBReg -> MBReg -> MBReg -> Ins
Lwi :: MBReg -> MBReg -> Word16 -> Ins
Mfs :: MBReg -> MBSReg -> Ins
Mts :: MBSReg -> MBReg -> Ins
Mul :: MBReg -> MBReg -> MBReg -> Ins
Mulhu :: MBReg -> MBReg -> MBReg -> Ins
Mulhsu :: MBReg -> MBReg -> MBReg -> Ins
Muli :: MBReg -> MBReg -> Word16 -> Ins
Or :: MBReg -> MBReg -> MBReg -> Ins
Ori :: MBReg -> MBReg -> Word16 -> Ins
Pcmpbf :: MBReg -> MBReg -> MBReg -> Ins
Pcmpne :: MBReg -> MBReg -> MBReg -> Ins
Put :: MBReg -> Int -> Ins
Nput :: MBReg -> Int -> Ins
Cput :: MBReg -> Int -> Ins
Ncput :: MBReg -> Int -> Ins
Rsub :: MBReg -> MBReg -> MBReg -> Ins
Rsubc :: MBReg -> MBReg -> MBReg -> Ins
Rsubk :: MBReg -> MBReg -> MBReg -> Ins
Rsubkc :: MBReg -> MBReg -> MBReg -> Ins
Rsubi :: MBReg -> MBReg -> Word16 -> Ins
Rsubic :: MBReg -> MBReg -> Word16 -> Ins
Rsubik :: MBReg -> MBReg -> Word16 -> Ins
Rsubikc :: MBReg -> MBReg -> Word16 -> Ins
Rtbd :: MBReg -> Word16 -> Ins
Rtid :: MBReg -> Word16 -> Ins
Rted :: MBReg -> Word16 -> Ins
Rtsd :: MBReg -> Word16 -> Ins
Sb :: MBReg -> MBReg -> MBReg -> Ins
Sbi :: MBReg -> MBReg -> Word16 -> Ins
Sext8 :: MBReg -> MBReg -> Ins
Sext16 :: MBReg -> MBReg -> Ins
Sh :: MBReg -> MBReg -> MBReg -> Ins
Shi :: MBReg -> MBReg -> Word16 -> Ins
Sra :: MBReg -> MBReg -> Ins
Src :: MBReg -> MBReg -> Ins
Srl :: MBReg -> MBReg -> Ins
Sw :: MBReg -> MBReg -> MBReg -> Ins
Swi :: MBReg -> MBReg -> Word16 -> Ins
Wdc :: MBReg -> MBReg -> Ins
Wic :: MBReg -> MBReg -> Ins
Xor :: MBReg -> MBReg -> MBReg -> Ins
Xori :: MBReg -> MBReg -> Word16 -> Ins
instance GHC.Show.Show InsSet.Ins
instance GHC.Show.Show InsSet.MBSReg
instance GHC.Enum.Enum InsSet.MBReg
instance GHC.Read.Read InsSet.MBReg
instance GHC.Show.Show InsSet.MBReg
instance GHC.Show.Show InsSet.MBSize


module Decode
instance GHC.Show.Show Decode.RawIns


module MachineState.InstructionBuffer
data InstructionBuffer
InstructionBuffer :: Maybe Word32 -> Maybe Ins -> InstructionBuffer
[_decode] :: InstructionBuffer -> Maybe Word32
[_execute] :: InstructionBuffer -> Maybe Ins
type Address = Word32
emptyInstructionBuffer :: InstructionBuffer


module MachineState

-- | Full MicroBlaze Register Profile
data MicroBlaze
MicroBlaze :: MBRegisters -> RPC -> RMSR -> InstructionBuffer -> MicroBlaze

-- | Standard word size for MicroBlaze
type MBWord = Word32

-- | Creates a zero-initialized MicroBlaze controller
newMicroBlaze :: MicroBlaze

-- | Program Counter
type RPC = MBWord

-- | Gets the RPC from a MicroBlaze State
getRPC :: (Monad m) => StateT MicroBlaze m MBWord

-- | Sets the RPC in a MicroBlaze State
setRPC :: (Monad m) => MBWord -> StateT MicroBlaze m ()

-- | Sets a specified bit on the machine status register
setMSRBit :: (Monad m) => MachineStatusBit -> Bool -> StateT MicroBlaze m ()

-- | Gets the value of a specified MSR Bit
getMSRBit :: (Monad m) => MachineStatusBit -> StateT MicroBlaze m Bool

-- | Pulls the enture Machine Status Register as a 32-bit Word
pullMSR :: (Monad m) => StateT MicroBlaze m Word32

-- | Pushes an enture MSR as a 32-bit word
pushMSR :: (Monad m) => Word32 -> StateT MicroBlaze m ()

-- | The register store for the Microblaze
data MBRegisters

-- | zero-initialized register bank
emptyRegisters :: MBRegisters

-- | gets the value at a specified register
getRegister :: (Monad m) => MBReg -> StateT MicroBlaze m MBWord

-- | sets the value at a specified register
setRegister :: (Monad m) => MBReg -> MBWord -> StateT MicroBlaze m ()

-- | read a given register
readRegister :: MBReg -> MBRegisters -> MBWord
type Address = Word32

-- | loads a 32-bit word from memory
--   
--   <b>NOT YET IMPLEMENTED</b>
loadWord :: (Monad m) => Word32 -> StateT MicroBlaze m Word32

-- | loads a 16-bit half-word from memory
--   
--   <b>NOT YET IMPLEMENTED</b>
loadHalfWord :: (Monad m) => Word32 -> StateT MicroBlaze m Word16

-- | loads a byte from memory
--   
--   <b>NOT YET IMPLEMENTED</b>
loadByte :: (Monad m) => Word32 -> StateT MicroBlaze m Word8

-- | stores a 32-bit word in memory
--   
--   <b>NOT YET IMPLEMENTED</b>
storeWord :: (Monad m) => Word32 -> Word32 -> Word32 -> StateT MicroBlaze m ()

-- | stores a 16-bit half-word in memory
--   
--   <b>NOT YET IMPLEMENTED</b>
storeHalfWord :: (Monad m) => Word16 -> Word32 -> Word32 -> StateT MicroBlaze m ()

-- | stores a 8-bit byte in memory
--   
--   <b>NOT YET IMPLEMENTED</b>
storeByte :: (Monad m) => Word8 -> Word32 -> Word32 -> StateT MicroBlaze m ()
fetch :: Address -> State MicroBlaze Word32
pushInstructionBuffer :: InstructionBuffer -> State MicroBlaze ()
pullDecode :: State MicroBlaze (Maybe Word32)
pullExec :: State MicroBlaze (Maybe Ins)


module IO
printRegisters :: MicroBlaze -> IO ()
printRPC :: MicroBlaze -> IO ()
printRegister :: MicroBlaze -> MBReg -> IO ()
printMicroBlaze :: MicroBlaze -> IO ()
printStatus :: RMSR -> IO ()


module Interpreter
executeNext :: State MicroBlaze ()
nextPCAddress :: State MicroBlaze Address
isPositive :: Word32 -> Bool
isNegative :: Word32 -> Bool
lessThanOrEqualToZero :: Word32 -> Bool
exec :: (Monad m) => Ins -> StateT MicroBlaze m ()
addWithCarry :: (Num a, Ord a) => a -> a -> Bool -> (Bool, a)

-- | Delay Flag for Branching
type DelayFlag = Bool

-- | Branch Input Type
data BranchInput
TypeA :: MBReg -> MBReg -> BranchInput
TypeB :: MBReg -> Word16 -> BranchInput

-- | Absolute Branch Input Type
data AbsoluteBranchInput
AbsR :: MBReg -> AbsoluteBranchInput
AbsI :: Word16 -> AbsoluteBranchInput

-- | Isomorphism type
type Op = Word32 -> Word32 -> Word32

-- | execute a type a instruction using basic operators
execTypeA :: (Monad m) => Op -> MBReg -> MBReg -> MBReg -> StateT MicroBlaze m ()

-- | execute a type b instruction using basic operators
execTypeB :: (Monad m) => Op -> MBReg -> MBReg -> Word16 -> StateT MicroBlaze m ()

-- | SHOULD BE DEPRECATED
getBranchInputValue :: (Monad m) => BranchInput -> StateT MicroBlaze m Word32

-- | SHOULD BE DEPRECATED
getBranchRegisterA :: (Monad m) => BranchInput -> StateT MicroBlaze m Word32

-- | branch to an absolute address
absoluteBranch :: (Monad m) => AbsoluteBranchInput -> StateT MicroBlaze m ()

-- | branch to a relative address
branch :: (Monad m) => BranchInput -> (MBWord -> Bool) -> StateT MicroBlaze m ()

-- | adding mechanism for MicroBlaze (likely can be deprecated)
add :: (Monad m) => CarryFlag -> KeepFlag -> (MBReg, Either MBReg Word16) -> MBReg -> StateT MicroBlaze m ()

-- | hardware subtraction (likely can be deprecated)
sub :: (Monad m) => CarryFlag -> KeepFlag -> (MBReg, Either MBReg Word16) -> MBReg -> StateT MicroBlaze m ()
reverseSubtraction :: (Num a, Bits a, Ord a) => a -> a -> Bool -> (Bool, a)

-- | Carry Flag for adder
type CarryFlag = Bool

-- | Keep Flag for adder
type KeepFlag = Bool
data LoadSize
LWord :: LoadSize
LHalfWord :: LoadSize
LByte :: LoadSize

-- | Either-like datatype to differentiate TypeA and TypeB data
data ImmOrReg
Register :: MBReg -> ImmOrReg
Immediate :: Word16 -> ImmOrReg

-- | Loads data from memory, The two register offsets are added to obtain
--   an address
load :: (Monad m) => LoadSize -> MBReg -> MBReg -> ImmOrReg -> StateT MicroBlaze m ()
data StoreSize
SWord :: StoreSize
SHalfWord :: StoreSize
SByte :: StoreSize
store :: (Monad m) => StoreSize -> MBReg -> MBReg -> ImmOrReg -> StateT MicroBlaze m ()

-- | pulls either the MSR or PC register into given register
moveFromSRegister :: (Monad m) => MBReg -> MBSReg -> StateT MicroBlaze m ()

-- | puts a Word into a special purpose register. Does not support updates
--   to the program counter
moveToSRegister :: (Monad m) => MBSReg -> MBReg -> StateT MicroBlaze m ()

-- | links the current program counter value into the specified register
link :: (Monad m) => MBReg -> StateT MicroBlaze m ()

-- | sets the delay flag in the machine status register
delay :: (Monad m) => StateT MicroBlaze m ()

-- | returns the pc from a break, interrupt, or subroutine
returnFrom :: (Monad m) => MBReg -> Word16 -> StateT MicroBlaze m ()
sext8 :: (Monad m) => MBReg -> MBReg -> StateT MicroBlaze m ()
sext16 :: (Monad m) => MBReg -> MBReg -> StateT MicroBlaze m ()
shiftRightArithmetic :: (Monad m) => CarryFlag -> MBReg -> MBReg -> StateT MicroBlaze m ()
shiftRightLogical :: (Monad m) => MBReg -> MBReg -> StateT MicroBlaze m ()
logicalShiftRight :: (Bits a) => a -> (Bool, a)
arithmeticShiftRight :: (FiniteBits a) => a -> Bool -> (Bool, a)
leastSignificantHalfWord :: Word32 -> Word16
leastSignificantByte :: Word32 -> Word8
maybeSignExtend :: (Integral a, Integral b, FiniteBits a, FiniteBits b) => a -> Maybe b
showFiniteBits :: (FiniteBits a) => a -> String
backExtend :: (Integral a, Integral b, FiniteBits a, FiniteBits b) => a -> Maybe b


module MachineState.Execution
data InboundSignals
In :: Maybe (MBSize, LoadData, MBReg) -> Maybe Ins -> InboundSignals
[_readData] :: InboundSignals -> Maybe (MBSize, LoadData, MBReg)
[_instruction] :: InboundSignals -> Maybe Ins
data OutboundSignals
Out :: Address -> Maybe (Address, MBReg, MBSize) -> Maybe (Address, StoreData, MBSize) -> MicroBlaze -> OutboundSignals
[_nextInstruction] :: OutboundSignals -> Address
[_read] :: OutboundSignals -> Maybe (Address, MBReg, MBSize)
[_write] :: OutboundSignals -> Maybe (Address, StoreData, MBSize)
[_st] :: OutboundSignals -> MicroBlaze
type StoreData = Word32
type LoadData = Word32
type MBlazeRe m = ReacT InboundSignals OutboundSignals (StateT MicroBlaze m)
startFDE :: (Monad m) => MBlazeRe m ()
fde :: (Monad m) => InboundSignals -> MBlazeRe m ()
incrementPC :: (Monad m) => StateT MicroBlaze m ()
makeOutbound :: (Monad m) => Maybe Ins -> StateT MicroBlaze m OutboundSignals
processWrite :: (Monad m) => Ins -> StateT MicroBlaze m (Maybe (Address, StoreData, MBSize))
unpackWrite :: Ins -> Maybe (MBReg, MBReg, Either Word16 MBReg, MBSize)
processLoad :: (Monad m) => Ins -> StateT MicroBlaze m (Maybe (Address, MBReg, MBSize))
unpackLoad :: Ins -> Maybe (MBReg, MBReg, Either Word16 MBReg, MBSize)
processIncomingMemory :: (Monad m) => InboundSignals -> StateT MicroBlaze m ()

module ParserMicroBlaze
expandFilePath :: FilePath -> IO FilePath
parseMB :: FilePath -> IO b
parseREPL :: IO [Command]
data Op
Plus :: Op
Minus :: Op
Times :: Op
Div :: Op
data Exp
Const :: Int -> Exp
Aexp :: Op -> Exp -> Exp -> Exp
data Oper
Register :: Int -> Oper
data Imm
Immed :: Int -> Imm
type Command = Ins
parseOp :: Parser Op
parseConst :: Parser Exp
parseAexp :: Parser Exp
parseReg :: Parser MBReg
parseSpecReg :: Parser MBSReg
numToReg :: Int -> Maybe MBReg
parseImm :: Parser Word16
parseExp :: Parser Exp
parseCommand :: Parser Command
parseAdd :: Parser Command
parseAddc :: Parser Command
parseAddk :: Parser Command
parseAddkc :: Parser Command
parseAddi :: Parser Command
parseAddic :: Parser Command
parseAddik :: Parser Command
parseAddikc :: Parser Command
parseAnd :: Parser Command
parseAndi :: Parser Command
parseAndn :: Parser Command
parseAndni :: Parser Command
parseBsrl :: Parser Command
parseBsra :: Parser Command
parseBsll :: Parser Command
parseBsrli :: Parser Command
parseBsrai :: Parser Command
parseBslli :: Parser Command
parseCmp :: Parser Command
parseCmpu :: Parser Command
parseIdiv :: Parser Command
parseIdivu :: Parser Command
parseLbu :: Parser Command
parseLbui :: Parser Command
parseLhu :: Parser Command
parseLhui :: Parser Command
parseLw :: Parser Command
parseLwi :: Parser Command
parseMul :: Parser Command
parseMuli :: Parser Command
parseOr :: Parser Command
parseOri :: Parser Command
parseRsub :: Parser Command
parseRsubc :: Parser Command
parseRsubk :: Parser Command
parseRsubkc :: Parser Command
parseRsubi :: Parser Command
parseRsubic :: Parser Command
parseRsubik :: Parser Command
parseRsubikc :: Parser Command
parseSb :: Parser Command
parseSbi :: Parser Command
parseSh :: Parser Command
parseShi :: Parser Command
parseSw :: Parser Command
parseSwi :: Parser Command
parseXor :: Parser Command
parseXori :: Parser Command
parseBeq :: Parser Command
parseBeqd :: Parser Command
parseBeqi :: Parser Command
parseBeqid :: Parser Command
parseBge :: Parser Command
parseBged :: Parser Command
parseBgei :: Parser Command
parseBgeid :: Parser Command
parseBgt :: Parser Command
parseBgtd :: Parser Command
parseBgti :: Parser Command
parseBgtid :: Parser Command
parseBle :: Parser Command
parseBled :: Parser Command
parseBlei :: Parser Command
parseBleid :: Parser Command
parseBlt :: Parser Command
parseBltd :: Parser Command
parseBlti :: Parser Command
parseBltid :: Parser Command
parseBne :: Parser Command
parseBned :: Parser Command
parseBnei :: Parser Command
parseBneid :: Parser Command
parseBrld :: Parser Command
parseBrald :: Parser Command
parseBrlid :: Parser Command
parseBralid :: Parser Command
parseBrk :: Parser Command
parseBrki :: Parser Command
parseMfs :: Parser Command
parseMts :: Parser Command
parseRtbd :: Parser Command
parseRtid :: Parser Command
parseRtsd :: Parser Command
parseSextHex :: Parser Command
parseSextOct :: Parser Command
parseSra :: Parser Command
parseSrc :: Parser Command
parseSrl :: Parser Command
parseWic :: Parser Command
parseBr :: Parser Command
parseBra :: Parser Command
parseBrad :: Parser Command
parseBri :: Parser Command
parseBrai :: Parser Command
parseBrid :: Parser Command
parseBraid :: Parser Command
instance GHC.Show.Show ParserMicroBlaze.Imm
instance GHC.Show.Show ParserMicroBlaze.Oper
instance GHC.Show.Show ParserMicroBlaze.Exp
instance GHC.Show.Show ParserMicroBlaze.Op


module REPL
runFreshRepl :: IO ((), MicroBlaze)
repl :: OutboundSignals -> StateT MicroBlaze IO (InboundSignals)
postWrite :: Maybe (Address, StoreData, MBSize) -> IO ()
getRead :: Maybe (Address, MBReg, MBSize) -> IO (Maybe (MBSize, LoadData, MBReg))
buildInstruction :: Address -> IO (Ins)


module TestData
