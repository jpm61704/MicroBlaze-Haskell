-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Short description of your package
--   
--   Please see the README on Github at
--   <a>https://github.com/githubuser/MicroBlaze#readme</a>
@package MicroBlaze
@version 0.1.0.0

module Parsing
data Parser a
P :: (String -> [(a, String)]) -> Parser a
failure :: Parser a
item :: Parser Char
parse :: Parser a -> String -> [(a, String)]
(+++) :: Parser a -> Parser a -> Parser a
infixr 5 +++
sat :: (Char -> Bool) -> Parser Char
digit :: Parser Char
lower :: Parser Char
upper :: Parser Char
letter :: Parser Char
alphanum :: Parser Char
char :: Char -> Parser Char
string :: String -> Parser String
many :: Parser a -> Parser [a]
many1 :: Parser a -> Parser [a]
ident :: Parser String
nat :: Parser Int
int :: Parser Int
space :: Parser ()
token :: Parser a -> Parser a
identifier :: Parser String
natural :: Parser Int
integer :: Parser Int
symbol :: String -> Parser String
instance GHC.Base.Functor Parsing.Parser
instance GHC.Base.Alternative Parsing.Parser
instance GHC.Base.Applicative Parsing.Parser
instance GHC.Base.Monad Parsing.Parser
instance GHC.Base.MonadPlus Parsing.Parser


module MachineState.MachineStatusRegister
data RMSR

-- | a zero-initialized (All False) MSR
emptyRMSR :: RMSR

-- | gets the status register in the form of a 32-bit word
getMSRWord :: RMSR -> Word32

-- | sets the status register from a 32-bit MSR word
setMSRWord :: Word32 -> RMSR

-- | Various status flags in the Machine State Register
data MachineStatusBit
CarryCopy :: MachineStatusBit
DataCacheEnable :: MachineStatusBit
DivisionByZero :: MachineStatusBit
InstructionCacheEnable :: MachineStatusBit
FSLError :: MachineStatusBit
BreakInProgress :: MachineStatusBit
Carry :: MachineStatusBit
InterruptEnable :: MachineStatusBit
BuslockEnable :: MachineStatusBit
DelayEnable :: MachineStatusBit

-- | Get the status of a specified flag
getStatus :: MachineStatusBit -> RMSR -> Bool

-- | sets the machine status bit indicated to the desired boolean value
setStatus :: MachineStatusBit -> Bool -> RMSR -> RMSR
instance GHC.Show.Show MachineState.MachineStatusRegister.MachineStatusBit


module Interpreter


-- | A resumption monad transformer, based on the formulation in the
--   article <a>Cheap (But Functional) Threads</a> by William L. Harrison
--   and Adam Procter.
module Control.Monad.Resumption

-- | Resumption monad transformer.
newtype ResT m a
ResT :: m (Either a (ResT m a)) -> ResT m a
[deResT] :: ResT m a -> m (Either a (ResT m a))

-- | Runs a resumptive computation to exhaustion, producing its final
--   return value.
runResT :: (Monad m) => ResT m a -> m a

-- | Waits until the next tick.
tick :: Monad m => ResT m ()
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Resumption.ResT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Resumption.ResT
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Monad.Resumption.ResT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Resumption.ResT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Resumption.ResT m)
instance Control.Monad.Morph.MFunctor Control.Monad.Resumption.ResT


-- | A reactive resumption monad transformer, based on the formulation in
--   the article <a>Cheap (But Functional) Threads</a> by William L.
--   Harrison and Adam Procter.
module Control.Monad.Resumption.Reactive

-- | Reactive resumption monad transformer.
newtype ReacT input output m a
ReacT :: m (Either a (output, input -> ReacT input output m a)) -> ReacT input output m a
[deReacT] :: ReacT input output m a -> m (Either a (output, input -> ReacT input output m a))

-- | Outputs its argument, then waits for the next input and returns it.
signal :: Monad m => output -> ReacT input output m input

-- | Tennis operator.
(<~>) :: Monad m => ReacT i o m a -> ReacT o i m b -> ResT m (Either a b)

-- | A basic runner function. Provide the ReacT and a handler in the
--   underlying monad to run.
runReacT :: Monad m => ReacT input output m a -> (output -> m input) -> m a
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Resumption.Reactive.ReacT input output m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Resumption.Reactive.ReacT input output)
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Monad.Resumption.Reactive.ReacT input output m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Resumption.Reactive.ReacT input output m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Resumption.Reactive.ReacT input output m)
instance Control.Monad.Morph.MFunctor (Control.Monad.Resumption.Reactive.ReacT i o)

module Control.Monad.Resumption.Connectors

-- | The parallel operator for combining computations in ReacT that share
--   the same underlying monad and halting types. No guarantees are given
--   to which device's halting message will be seen by a handler.
(<||>) :: (Monad m) => ReacT i1 o1 m a -> ReacT i2 o2 m a -> ReacT (i1, i2) (o1, o2) m a
refoldT :: forall o1 o2 i1 i2 m a. Monad m => (o1 -> o2) -> (o1 -> i2 -> Maybe i1) -> ReacT i1 o1 m a -> ReacT i2 o2 m a

-- | The refold operator changes the output and input types of a reactive
--   resumption
refold :: (Monad m) => (o1 -> o2) -> (o1 -> i2 -> i1) -> ReacT i1 o1 m a -> ReacT i2 o2 m a

-- | Chains two reactive resumptions together in a pipelined fashioned.
--   That is, inputs and outputs are passed along between devices
--   "tickwise".
pipeline :: (Monad m) => ReacT i z m a -> ReacT z o m a -> ReacT i o m a

module Boilerplate.Machines.SpecialPurposeRegister

-- | A naming configuration for bits in a <tt>MachineStatus</tt> Register.
--   This provides name-based access to a bit in an msr based on the bits
--   function as a flag.
newtype BitConfiguration l
BitConf :: [Maybe l] -> BitConfiguration l

-- | an unnamed bit
--   
--   typically used to set aside space for flow related operations,
--   constants, or non-user accessible flags
blank :: BitConfiguration l

-- | Same as <a>blank</a> but for multiple blanks in order
blanks :: Int -> BitConfiguration l

-- | Defines a named bit that represents some flag in a Machine Status
--   Register(<tt>MachineStatus</tt>).
named :: l -> BitConfiguration l

-- | Same as <a>named</a>, but, provided a list of names, names the next n
--   bits according to the provided list. (where n is the number of names
--   provided)
names :: [l] -> BitConfiguration l
getNumber :: (Eq l) => BitConfiguration l -> l -> Maybe Int
nameNumPairs :: (FiniteBits r) => BitConfiguration bsl -> r -> [(bsl, Bool)]
instance Data.Semigroup.Semigroup (Boilerplate.Machines.SpecialPurposeRegister.BitConfiguration l)
instance GHC.Base.Monoid (Boilerplate.Machines.SpecialPurposeRegister.BitConfiguration l)
instance GHC.Show.Show l => GHC.Show.Show (Boilerplate.Machines.SpecialPurposeRegister.BitConfiguration l)

module Boilerplate.Machines

-- | A machine of inert(stateless) registers
data Machine l sl r
machine :: (FiniteBits r) => Int -> [String] -> Machine String String r
registers :: Machine l sl r -> RegisterBank l r

-- | A register bank with labels l and registers r
data RegisterBank l r

-- | Creates a new register bank using a generator functions to produce
--   label l
newRegisterBank :: (FiniteBits r, Ord l) => Int -> (Int -> l) -> RegisterBank l r

-- | produces a register bank with numeric labels proceeded by the
--   character <tt>r</tt>. For example the first register is "r0" Important
--   to note that this produces a strange order from labels being Strings
standardRegisterBank :: (FiniteBits r) => Int -> RegisterBank String r
getBank :: RegisterBank l r -> Map l r
setRegister :: (Ord l) => l -> r -> Machine l sl r -> Machine l sl r
getRegister :: (Ord l) => l -> Machine l sl r -> Maybe r
modifyRegister :: (Ord l) => l -> (r -> r) -> Machine l sl r -> Machine l sl r
type SpecialRegisters sl r = RegisterBank sl r
specialFromList :: (FiniteBits r, Ord l) => [l] -> SpecialRegisters l r
setSpecialRegister :: (Ord sl) => sl -> r -> Machine l sl r -> Machine l sl r
getSpecialRegister :: (Ord sl) => sl -> Machine l sl r -> Maybe r
modifySpecialRegister :: (Ord sl) => sl -> (r -> r) -> Machine l sl r -> Machine l sl r
setSPRBit :: (FiniteBits r, Ord sl) => sl -> Int -> Machine l sl r -> Machine l sl r
clearSPRBit :: (FiniteBits r, Ord sl) => sl -> Int -> Machine l sl r -> Machine l sl r
mb :: Machine String String Word32
instance (GHC.Show.Show sl, GHC.Show.Show l, GHC.Show.Show r) => GHC.Show.Show (Boilerplate.Machines.Machine l sl r)
instance (GHC.Show.Show r, GHC.Show.Show l) => GHC.Show.Show (Boilerplate.Machines.RegisterBank l r)

module Boilerplate.Machines.State

-- | Stateful Machine Definitions This should be an internal type only
type MachineST l sl r = StateT (Machine l sl r)
setRegister :: (Monad m, Ord l) => l -> r -> MachineST l sl r m ()
getRegister :: (Monad m, Ord l) => l -> MachineST l sl r m (Maybe r)
modifyRegister :: (Monad m, Ord l) => l -> (r -> r) -> MachineST l sl r m ()

-- | Conducts an operation on two register values and places the result in
--   a third register r_d
operate :: (Monad m, Ord l) => (r -> r -> r) -> l -> l -> l -> MachineST l sl r m r
operateWithImmediate :: (Monad m, Ord l) => (r -> r -> r) -> l -> r -> l -> MachineST l sl r m ()
getMultipleRegs :: (Monad m, Ord l) => [l] -> MachineST l sl r m (Maybe [r])
setSpecialRegister :: (Monad m, Ord sl) => sl -> r -> MachineST l sl r m ()
getSpecialRegister :: (Monad m, Ord sl) => sl -> MachineST l sl r m (Maybe r)
modifySpecialRegister :: (Monad m, Ord sl) => sl -> (r -> r) -> MachineST l sl r m ()
setSPRBit :: (Monad m, FiniteBits r, Ord sl) => sl -> Int -> MachineST l sl r m ()
clearSPRBit :: (Monad m, FiniteBits r, Ord sl) => sl -> Int -> MachineST l sl r m ()
setWithConfigTo :: (Eq bsl, Monad m, FiniteBits r, Ord sl) => sl -> BitConfiguration bsl -> bsl -> Bool -> MachineST l sl r m ()
setWithConfig :: (Eq bsl, Monad m, FiniteBits r, Ord sl) => sl -> BitConfiguration bsl -> bsl -> MachineST l sl r m ()
clearWithConfig :: (Eq bsl, Monad m, FiniteBits r, Ord sl) => sl -> BitConfiguration bsl -> bsl -> MachineST l sl r m ()
testWithConfig :: (Eq bsl, Monad m, FiniteBits r, Ord sl) => sl -> BitConfiguration bsl -> bsl -> MachineST l sl r m (Maybe Bool)
addWithCarry :: (FiniteBits r, Monad m, Ord l, Ord sl, Eq bsl, Num r, Ord r) => MSRBitAddress sl bsl -> r -> r -> l -> MachineST l sl r m Bool
applyCarry :: (Monad m, FiniteBits r, Ord sl, Eq bsl) => MSRBitAddress sl bsl -> Bool -> MachineST l sl r m ()
data MSRBitAddress sl bsl
BitAddr :: sl -> (BitConfiguration bsl) -> bsl -> MSRBitAddress sl bsl
branch :: (Monad m, Ord sl, Num r) => sl -> r -> MachineST l sl r m ()

module Boilerplate.Instruction

-- | The definition of some abstract instruction
data Instruction l sl r m a
Ins :: String -> ArgumentsForm l -> ExecutionFunction l sl r m a -> Instruction l sl r m a
[name] :: Instruction l sl r m a -> String
[form] :: Instruction l sl r m a -> ArgumentsForm l
[exec] :: Instruction l sl r m a -> ExecutionFunction l sl r m a
data Argument l r
Register :: l -> Argument l r
Immediate :: r -> Argument l r

-- | arguments to a command represent a mapping of register argument labels
--   to their register label or immediate data example: ra -&gt; r1 or rd
--   -&gt; r32, imm -&gt; 123
data Arguments l r
Args :: (Map l (Argument l r)) -> Arguments l r
newtype ArgumentsForm l
Form :: [(ArgumentForm, l)] -> ArgumentsForm l
data ArgumentForm
Reg :: ArgumentForm
Imm :: ArgumentForm
reg :: l -> ArgumentsForm l
imm :: l -> ArgumentsForm l
getArg :: (Ord l) => Arguments l r -> l -> Maybe (Argument l r)
unpackArgs :: (Ord l) => Arguments l r -> [l] -> Maybe [Argument l r]
formToList :: ArgumentsForm l -> [l]
unpackFromForm :: (Ord l) => ArgumentsForm l -> Arguments l r -> Maybe [Argument l r]

-- | the command that actually executes on a machine
data Command l sl r m a
Command :: (Instruction l sl r m a) -> (Arguments l r) -> Command l sl r m a
[instruction] :: Command l sl r m a -> (Instruction l sl r m a)
[arguments] :: Command l sl r m a -> (Arguments l r)
getExec :: Command l sl r m a -> ExecutionFunction l sl r m a
getArgs :: Command l sl r m a -> Arguments l r
unpackCommand :: Command l sl r m a -> (Arguments l r, ExecutionFunction l sl r m a)

-- | function that executes on the state given a set of arguments
type ExecutionFunction l sl r m a = ReaderT (Arguments l r) (MachineST l sl r m) a
type InstructionSet l sl r m a = Map String (Instruction l sl r m a)
execute :: Command l sl r m a -> MachineST l sl r m a
argsFromList :: (Ord l) => [(l, Argument l r)] -> Arguments l r
setFromList :: [Instruction l sl r m a] -> InstructionSet l sl r m a
instance (GHC.Show.Show l, GHC.Show.Show r) => GHC.Show.Show (Boilerplate.Instruction.Command l sl r m a)
instance Data.Semigroup.Semigroup (Boilerplate.Instruction.ArgumentsForm l)
instance GHC.Base.Monoid (Boilerplate.Instruction.ArgumentsForm l)
instance (GHC.Show.Show r, GHC.Show.Show l) => GHC.Show.Show (Boilerplate.Instruction.Arguments l r)
instance (GHC.Show.Show r, GHC.Show.Show l) => GHC.Show.Show (Boilerplate.Instruction.Argument l r)
instance (GHC.Read.Read r, GHC.Read.Read l) => GHC.Read.Read (Boilerplate.Instruction.Argument l r)
instance GHC.Show.Show (Boilerplate.Instruction.Instruction l sl r m a)

module Boilerplate.Parse
parseCommand :: (Integral r, Read l, Ord l) => Parser l -> InstructionSet l sl r m a -> Parser (Command l sl r m a)
parseInstruction :: InstructionSet l sl r m a -> Parser (Instruction l sl r m a)
parseArgs :: (Integral r, Read l, Ord l) => (Parser l) -> ArgumentsForm l -> Parser (Arguments l r)
parseArg :: (Integral r, Ord l) => Parser l -> (ArgumentForm, l) -> Parser (l, Argument l r)
parseRegister :: Parser l -> Parser (Argument l r)
parseData :: (Integral r) => Parser (Argument l r)
parseRepl :: (Integral r, Read l, Ord l) => Parser l -> InstructionSet l sl r m a -> IO (Maybe (Command l sl r m a))

module Boilerplate.IO
printMachine :: (Show l, FiniteBits r, Show r, Integral r, Show bsl, Ord sl) => (BitConfiguration bsl, sl) -> sl -> Machine l sl r -> IO ()
printProgramCounter :: (Ord sl, Show r) => sl -> Machine l sl r -> IO ()
printRegisterBank :: (Show l, FiniteBits r, Show r, Integral r) => RegisterBank l r -> IO ()
printSpecialRegisters :: (Show sl) => SpecialRegisters sl r -> IO ()
printRegister :: (FiniteBits r, Show r, Integral r) => String -> r -> IO ()
prettyReg :: (FiniteBits r, Show r, Integral r) => String -> r -> String
prettybits :: (FiniteBits r) => r -> String
test1 :: IO ()
printMSR :: (FiniteBits r, Show bsl) => BitConfiguration bsl -> r -> IO ()

module Boilerplate.Execution
type In l sl r m a = Maybe (Command l sl r m a)
type Out = String
type MachineReacT l sl r m a = ReacT (In l sl r m a) Out (MachineST l sl r m) a
data MachineDefinition l sl r m a
MachineDef :: Machine l sl r -> InstructionSet l sl r m a -> (Machine l sl r -> IO ()) -> Parser l -> MachineDefinition l sl r m a
[machine] :: MachineDefinition l sl r m a -> Machine l sl r
[insSet] :: MachineDefinition l sl r m a -> InstructionSet l sl r m a
[prnt] :: MachineDefinition l sl r m a -> (Machine l sl r -> IO ())
[_parse] :: MachineDefinition l sl r m a -> Parser l
runMachine :: (Integral r, Ord l, Read l) => MachineDefinition l sl r IO a -> IO ()
startBasicFDE :: (Monad m) => MachineReacT l sl r m a
basicFDE :: (Monad m) => In l sl r m a -> MachineReacT l sl r m a
basicREPL :: (Integral r, Read l, Ord l) => InstructionSet l sl r m a -> Parser l -> (Machine l sl r -> IO ()) -> Out -> MachineST l sl r IO (In l sl r m a)


module Boilerplate

-- | Standard Bit Datatype Supporting functions can be found in
--   <a>Boilerplate.Bit</a>
data Bit
C :: Bit
S :: Bit

-- | show instance of Bit displays bits as 1 and 0

-- | Standard Byte defintion Supporting functions can be found in
--   <a>Boilerplate.W8</a>
data W8
W8 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> W8

-- | 16-bit data
data W16
W16 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> W16

-- | 32-bit data Supporting functions can be found in
--   <a>Boilerplate.W32</a>
data W32
W32 :: W8 -> W8 -> W8 -> W8 -> W32

-- | 5-bit data
data W5
W5 :: Bit -> Bit -> Bit -> Bit -> Bit -> W5

-- | 6-bit data
data W6
W6 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> W6

-- | 11-bit data
data W11
W11 :: Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> W11
maybeSignExtend :: (Integral a, Integral b, FiniteBits a, FiniteBits b) => a -> Maybe b
showFiniteBits :: (FiniteBits a) => a -> String
instance GHC.Show.Show Boilerplate.W11
instance GHC.Show.Show Boilerplate.W6
instance GHC.Show.Show Boilerplate.W5
instance GHC.Show.Show Boilerplate.W16
instance GHC.Show.Show Boilerplate.Bit
instance GHC.Show.Show Boilerplate.W8
instance GHC.Show.Show Boilerplate.W32


module Boilerplate.Bit

-- | bit negation <tt> not S = C not C = S </tt>
not :: Bit -> Bit

-- | equality
(==) :: Bit -> Bit -> Bit

-- | logical AND
and :: Bit -> Bit -> Bit

-- | logical OR
or :: Bit -> Bit -> Bit

-- | logical exclusive OR
xor :: Bit -> Bit -> Bit

-- | Binary additon with carries
plus :: Bit -> Bit -> Bit -> (Bit, Bit)

-- | Binary subtraction with carries
minus :: Bit -> Bit -> Bit -> (Bit, Bit)
toInteger :: Bit -> Int


module Boilerplate.W8

-- | zero-byte (00000000)
zero :: W8

-- | one-byte (00000001)
one :: W8

-- | logical not
not :: W8 -> W8

-- | logical and
and :: W8 -> W8 -> W8

-- | logical or
or :: W8 -> W8 -> W8

-- | logical exclusive or
xor :: W8 -> W8 -> W8

-- | logical equality (as opposed to bitwise)
(==) :: W8 -> W8 -> Bit

-- | left rotation
rotateLeft :: W8 -> W8

-- | right rotation
rotateRight :: W8 -> W8

-- | left shift with carry
shiftLeft :: W8 -> Bit -> (Bit, W8)

-- | right shift with carry
shiftRight :: W8 -> Bit -> (Bit, W8)

-- | most significant bit of byte
--   
--   also is the sign-bit
mostSignificantBit :: W8 -> Bit

-- | least significant bit of byte
leastSignificantBit :: W8 -> Bit

-- | addition with carry
add :: W8 -> W8 -> Bit -> (Bit, W8)

-- | subtraction with carry
subtract :: W8 -> W8 -> Bit -> (Bit, W8)

-- | two's complement negation
negative :: W8 -> W8

-- | tests negativity
isNegative :: W8 -> Bit
arithmeticShiftRight :: W8 -> Bit -> (Bit, W8)
logicalShiftRight :: W8 -> (Bit, W8)
toInteger :: W8 -> Int
fromInteger :: Int -> W8

module Boilerplate.W16
fromInteger :: Int -> W16


module Boilerplate.W32

-- | zero value (00000000 00000000 00000000 00000000)
zero :: W32

-- | one value (00000000 00000000 00000000 00000001)
one :: W32
four :: W32

-- | Logical AND
and :: W32 -> W32 -> W32

-- | Logical OR
or :: W32 -> W32 -> W32

-- | Logical NOT
not :: W32 -> W32

-- | equality
(==) :: W32 -> W32 -> Bit
xor :: W32 -> W32 -> W32

-- | two's complement 16-bit sign extension
signExtendW16 :: W16 -> W32

-- | unsigned 16-bit extension
unsignedExtendW16 :: W16 -> W32

-- | two's complement byte sign extension
signExtendW8 :: W8 -> W32

-- | unsigned byte extension
unsignedExtendW8 :: W8 -> W32

-- | back-extends 16-bit data (useful for certain register operations)
--   
--   example : 1010 0011 -&gt; 1010 0011 0000 0000
backExtendW16 :: W16 -> W32

-- | the least significant byte
leastSignificantByte :: W32 -> W8

-- | the least significat hald-word
leastSignificantHalfWord :: W32 -> W16

-- | addition with carries
add :: W32 -> W32 -> Bit -> (Bit, W32)

-- | subtraction with carries
subtract :: W32 -> W32 -> Bit -> (Bit, W32)

-- | subtraction-based comparison with sign-preservation
signedCompare :: W32 -> W32 -> W32

-- | unsigned subtraction comparison
unsignedCompare :: W32 -> W32 -> W32

-- | test if value is negative under two's complement
isNegative :: W32 -> Bit

-- | test if a value is positive or zero under two's complement
isPositive :: W32 -> Bit

-- | test if a value is zero
isZero :: W32 -> Bit

-- | test if a value is greater than zero under two's complement
greaterThanZero :: W32 -> Bit

-- | test if a value is less than or equal to zero under two's complement
lessThanOrEqualToZero :: W32 -> Bit

-- | reverse subtraction
--   
--   rb + not(ra) + carry
reverseSubtraction :: W32 -> W32 -> Bit -> (Bit, W32)
arithmeticShiftRight :: W32 -> Bit -> (Bit, W32)
logicalShiftRight :: W32 -> (Bit, W32)
toInteger :: W32 -> Int
fromInteger :: Int -> W32


module InsSet

-- | Possible data sizes
data MBSize
ByteSize :: MBSize
HalfWordSize :: MBSize
WordSize :: MBSize

-- | All user-accesible general-purpose registers
data MBReg

-- | Dedicated, Value 0
R0 :: MBReg

-- | Dedicated, Stack Pointer
R1 :: MBReg

-- | Dedicated, Read-only small data area anchor
R2 :: MBReg

-- | Volatile, Return Value
R3 :: MBReg

-- | Volatile, Return Value
R4 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R5 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R6 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R7 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R8 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R9 :: MBReg

-- | Volatile, Passing Parameter / Temporary
R10 :: MBReg

-- | Volatile, Temporary
R11 :: MBReg

-- | Volatile, Temporary
R12 :: MBReg

-- | Dedicated, Read-write small data area anchor
R13 :: MBReg

-- | Dedicated, Return address for Interrupt
R14 :: MBReg

-- | Dedicated, Return address for Sub-routine
R15 :: MBReg

-- | Dedicated, Return address for Trap (Debugger)
R16 :: MBReg

-- | Dedicated, Return address for Exceptions
R17 :: MBReg

-- | Dedicated, Reserved for assembler, used for Imm instruction
R18 :: MBReg

-- | Non-volatile, must be saved across function calls
R19 :: MBReg

-- | Non-volatile, must be saved across function calls
R20 :: MBReg

-- | Non-volatile, must be saved across function calls
R21 :: MBReg

-- | Non-volatile, must be saved across function calls
R22 :: MBReg

-- | Non-volatile, must be saved across function calls
R23 :: MBReg

-- | Non-volatile, must be saved across function calls
R24 :: MBReg

-- | Non-volatile, must be saved across function calls
R25 :: MBReg

-- | Non-volatile, must be saved across function calls
R26 :: MBReg

-- | Non-volatile, must be saved across function calls
R27 :: MBReg

-- | Non-volatile, must be saved across function calls
R28 :: MBReg

-- | Non-volatile, must be saved across function calls
R29 :: MBReg

-- | Non-volatile, must be saved across function calls
R30 :: MBReg

-- | Non-volatile, must be saved across function calls
R31 :: MBReg

-- | Special Purpose Registers
data MBSReg

-- | Program Counter
RPC :: MBSReg

-- | Machine Status Register
MSR :: MBSReg

-- | The MicroBlaze Instruction Set
data Ins
Add :: MBReg -> MBReg -> MBReg -> Ins
Addc :: MBReg -> MBReg -> MBReg -> Ins
Addk :: MBReg -> MBReg -> MBReg -> Ins
Addkc :: MBReg -> MBReg -> MBReg -> Ins
Addi :: MBReg -> MBReg -> Word16 -> Ins
Addic :: MBReg -> MBReg -> Word16 -> Ins
Addik :: MBReg -> MBReg -> Word16 -> Ins
Addikc :: MBReg -> MBReg -> Word16 -> Ins
And :: MBReg -> MBReg -> MBReg -> Ins
Andi :: MBReg -> MBReg -> Word16 -> Ins
Andn :: MBReg -> MBReg -> MBReg -> Ins
Andni :: MBReg -> MBReg -> Word16 -> Ins
Beq :: MBReg -> MBReg -> Ins
Beqd :: MBReg -> MBReg -> Ins
Beqi :: MBReg -> Word16 -> Ins
Beqid :: MBReg -> Word16 -> Ins
Bge :: MBReg -> MBReg -> Ins
Bged :: MBReg -> MBReg -> Ins
Bgei :: MBReg -> Word16 -> Ins
Bgeid :: MBReg -> Word16 -> Ins
Bgt :: MBReg -> MBReg -> Ins
Bgtd :: MBReg -> MBReg -> Ins
Bgti :: MBReg -> Word16 -> Ins
Bgtid :: MBReg -> Word16 -> Ins
Ble :: MBReg -> MBReg -> Ins
Bled :: MBReg -> MBReg -> Ins
Blei :: MBReg -> Word16 -> Ins
Bleid :: MBReg -> Word16 -> Ins
Blt :: MBReg -> MBReg -> Ins
Bltd :: MBReg -> MBReg -> Ins
Blti :: MBReg -> Word16 -> Ins
Bltid :: MBReg -> Word16 -> Ins
Bne :: MBReg -> MBReg -> Ins
Bned :: MBReg -> MBReg -> Ins
Bnei :: MBReg -> Word16 -> Ins
Bneid :: MBReg -> Word16 -> Ins
Br :: MBReg -> Ins
Bra :: MBReg -> Ins
Brd :: MBReg -> Ins
Brad :: MBReg -> Ins
Brld :: MBReg -> MBReg -> Ins
Brald :: MBReg -> MBReg -> Ins
Bri :: Word16 -> Ins
Brai :: Word16 -> Ins
Brid :: Word16 -> Ins
Braid :: Word16 -> Ins
Brlid :: MBReg -> Word16 -> Ins
Bralid :: MBReg -> Word16 -> Ins
Brk :: MBReg -> MBReg -> Ins
Brki :: MBReg -> Word16 -> Ins
Bsrl :: MBReg -> MBReg -> MBReg -> Ins
Bsra :: MBReg -> MBReg -> MBReg -> Ins
Bsll :: MBReg -> MBReg -> MBReg -> Ins
Bsrli :: MBReg -> MBReg -> Word16 -> Ins
Bsrai :: MBReg -> MBReg -> Word16 -> Ins
Bslli :: MBReg -> MBReg -> Word16 -> Ins
Cmp :: MBReg -> MBReg -> MBReg -> Ins
Cmpu :: MBReg -> MBReg -> MBReg -> Ins
Get :: MBReg -> Int -> Ins
Nget :: MBReg -> Int -> Ins
Cget :: MBReg -> Int -> Ins
Ncget :: MBReg -> Int -> Ins
Idiv :: MBReg -> MBReg -> MBReg -> Ins
Idivu :: MBReg -> MBReg -> MBReg -> Ins
Imm :: Word16 -> Ins
Lbu :: MBReg -> MBReg -> MBReg -> Ins
Lbui :: MBReg -> MBReg -> Word16 -> Ins
Lhu :: MBReg -> MBReg -> MBReg -> Ins
Lhui :: MBReg -> MBReg -> Word16 -> Ins
Lw :: MBReg -> MBReg -> MBReg -> Ins
Lwi :: MBReg -> MBReg -> Word16 -> Ins
Mfs :: MBReg -> MBSReg -> Ins
Mts :: MBSReg -> MBReg -> Ins
Mul :: MBReg -> MBReg -> MBReg -> Ins
Mulhu :: MBReg -> MBReg -> MBReg -> Ins
Mulhsu :: MBReg -> MBReg -> MBReg -> Ins
Muli :: MBReg -> MBReg -> Word16 -> Ins
Or :: MBReg -> MBReg -> MBReg -> Ins
Ori :: MBReg -> MBReg -> Word16 -> Ins
Pcmpbf :: MBReg -> MBReg -> MBReg -> Ins
Pcmpne :: MBReg -> MBReg -> MBReg -> Ins
Put :: MBReg -> Int -> Ins
Nput :: MBReg -> Int -> Ins
Cput :: MBReg -> Int -> Ins
Ncput :: MBReg -> Int -> Ins
Rsub :: MBReg -> MBReg -> MBReg -> Ins
Rsubc :: MBReg -> MBReg -> MBReg -> Ins
Rsubk :: MBReg -> MBReg -> MBReg -> Ins
Rsubkc :: MBReg -> MBReg -> MBReg -> Ins
Rsubi :: MBReg -> MBReg -> Word16 -> Ins
Rsubic :: MBReg -> MBReg -> Word16 -> Ins
Rsubik :: MBReg -> MBReg -> Word16 -> Ins
Rsubikc :: MBReg -> MBReg -> Word16 -> Ins
Rtbd :: MBReg -> Word16 -> Ins
Rtid :: MBReg -> Word16 -> Ins
Rted :: MBReg -> Word16 -> Ins
Rtsd :: MBReg -> Word16 -> Ins
Sb :: MBReg -> MBReg -> MBReg -> Ins
Sbi :: MBReg -> MBReg -> Word16 -> Ins
Sext8 :: MBReg -> MBReg -> Ins
Sext16 :: MBReg -> MBReg -> Ins
Sh :: MBReg -> MBReg -> MBReg -> Ins
Shi :: MBReg -> MBReg -> Word16 -> Ins
Sra :: MBReg -> MBReg -> Ins
Src :: MBReg -> MBReg -> Ins
Srl :: MBReg -> MBReg -> Ins
Sw :: MBReg -> MBReg -> MBReg -> Ins
Swi :: MBReg -> MBReg -> Word16 -> Ins
Wdc :: MBReg -> MBReg -> Ins
Wic :: MBReg -> MBReg -> Ins
Xor :: MBReg -> MBReg -> MBReg -> Ins
Xori :: MBReg -> MBReg -> Word16 -> Ins
instance GHC.Show.Show InsSet.Ins
instance GHC.Show.Show InsSet.MBSReg
instance GHC.Enum.Enum InsSet.MBReg
instance GHC.Read.Read InsSet.MBReg
instance GHC.Show.Show InsSet.MBReg
instance GHC.Show.Show InsSet.MBSize


module Decode
instance GHC.Show.Show Decode.RawIns


module MachineState

-- | Full MicroBlaze Register Profile
type MicroBlaze = Machine String String Word32

-- | Creates a zero-initialized MicroBlaze controller
newMicroBlaze :: MicroBlaze


module IO

module InstructionSet
mbDefinition :: MachineDefinition String String Word32 IO ()
type MBInstruction m = Instruction String String Word32 m
data MBControl
MBControl :: Bool -> Bool -> Bool -> MBControl
[delayFlag] :: MBControl -> Bool
[loadFlag] :: MBControl -> Bool
[storeFlag] :: MBControl -> Bool
endOP :: ExecutionFunction String String Word32 IO MBControl
withDelay :: ExecutionFunction String String Word32 IO MBControl
instructionList :: InstructionSet String String Word32 IO ()
compareU :: (Monad m) => String -> String -> ExecutionFunction String String Word32 m ()
carryAddr :: MSRBitAddress String StatusBits
formA :: ArgumentsForm String
formB :: ArgumentsForm String
formBranchA :: ArgumentsForm String
formBranchB :: ArgumentsForm String
formUnconditionalBranch :: ArgumentsForm String
formUBranchWithLink :: ArgumentsForm String
parseMBReg :: Parser String
data StatusBits
CC :: StatusBits
VMS :: StatusBits
VM :: StatusBits
UMS :: StatusBits
UM :: StatusBits
PVR :: StatusBits
EIP :: StatusBits
EE :: StatusBits
DCE :: StatusBits
DZ :: StatusBits
ICE :: StatusBits
FSL :: StatusBits
BIP :: StatusBits
C :: StatusBits
IE :: StatusBits
BE :: StatusBits
msrBitConf :: BitConfiguration StatusBits
testStatus :: (Monad m) => StatusBits -> MachineST l String Word32 m (Maybe Bool)
getRegisterValues :: (Monad m, Ord l) => [Argument l r] -> MachineST l sl r m (Maybe [r])
maybeCons :: Maybe x -> Maybe [x] -> Maybe [x]
typeA :: (Monad m) => (Word32 -> Word32 -> Word32) -> ExecutionFunction String String Word32 m ()
typeB :: (Monad m) => (Word32 -> Word32 -> Word32) -> ExecutionFunction String String Word32 m ()
addToPC :: (Monad m) => Word32 -> ExecutionFunction String String Word32 m ()
destFromAB :: (Monad m) => (Word32 -> Word32 -> Word32) -> ArgumentsForm String -> ExecutionFunction String String Word32 m ()
destFromABWithCarry :: (Monad m) => (Word32 -> Word32 -> Bool -> Word32) -> ArgumentsForm String -> ExecutionFunction String String Word32 m ()

-- | takes a list of argument names (ex: ra, rb, imm, etc.) and returns
--   their values in terms of the current state
getLiteralValuesForArgs :: (Monad m, Ord l) => [l] -> ExecutionFunction l sl r m (Map l r)
findVal :: (Monad m, Ord l) => Argument l r -> MachineST l sl r m (Maybe r)
getLiteralValueForArg :: (Monad m, Ord l) => l -> ExecutionFunction l sl r m (Maybe r)
operateOn :: (Monad m, Ord l) => (r -> r -> a) -> (l, l) -> ExecutionFunction l sl r m a
placeResultAt :: (Monad m, Ord l) => l -> r -> ExecutionFunction l sl r m ()
testCarry :: (Monad m) => ExecutionFunction String String Word32 m Bool
setCarryTo :: (Monad m) => Bool -> ExecutionFunction String String Word32 m ()

-- | check if overflow will occur from addition
overflow :: (Num r, FiniteBits r, Ord r) => r -> r -> r -> Bool
addRegular :: (Monad m) => (String, String) -> ExecutionFunction String String Word32 m ()
add :: (Monad m) => (String, String) -> Bool -> ExecutionFunction String String Word32 m Bool
keep :: (Monad m) => Bool -> ExecutionFunction String String Word32 m ()
carryOut :: (Monad m) => Bool -> ExecutionFunction String String Word32 m ()
addWithCarryS :: (Monad m) => (String, String) -> ExecutionFunction String String Word32 m Bool
addc :: (Num r, FiniteBits r, Ord r) => Bool -> r -> r -> (r, Bool)
withArg :: (Ord l, Monad m) => l -> (r -> ExecutionFunction l sl r m a) -> ExecutionFunction l sl r m a
with :: (Ord l, Monad m) => (r -> ExecutionFunction l sl r m a) -> l -> ExecutionFunction l sl r m a
with2 :: (Ord l, Monad m) => (r -> r -> ExecutionFunction l sl r m a) -> (l, l) -> ExecutionFunction l sl r m a

-- | Check a predicate against an argument's state value
(.?.) :: (Ord l, Monad m) => l -> (r -> ExecutionFunction l sl r m Bool) -> ExecutionFunction l sl r m Bool
ifTrue :: (Monad m, Ord l) => ExecutionFunction l sl r m a -> Bool -> ExecutionFunction l sl r m ()
branchIf :: (Monad m) => String -> (Word32 -> Bool) -> String -> ExecutionFunction String String Word32 m ()
instance GHC.Classes.Eq InstructionSet.StatusBits
instance GHC.Show.Show InstructionSet.StatusBits


module MachineState.Execution


module MachineState.InstructionBuffer
data InstructionBuffer
InstructionBuffer :: Maybe Word32 -> Maybe Ins -> InstructionBuffer
[_decode] :: InstructionBuffer -> Maybe Word32
[_execute] :: InstructionBuffer -> Maybe Ins
type Address = Word32
emptyInstructionBuffer :: InstructionBuffer

module ParserMicroBlaze
expandFilePath :: FilePath -> IO FilePath
parseMB :: FilePath -> IO b
parseREPL :: IO [Command]
data Op
Plus :: Op
Minus :: Op
Times :: Op
Div :: Op
data Exp
Const :: Int -> Exp
Aexp :: Op -> Exp -> Exp -> Exp
data Oper
Register :: Int -> Oper
data Imm
Immed :: Int -> Imm
type Command = Ins
parseOp :: Parser Op
parseConst :: Parser Exp
parseAexp :: Parser Exp
parseReg :: Parser MBReg
parseSpecReg :: Parser MBSReg
numToReg :: Int -> Maybe MBReg
parseImm :: Parser Word16
parseExp :: Parser Exp
parseCommand :: Parser Command
parseAdd :: Parser Command
parseAddc :: Parser Command
parseAddk :: Parser Command
parseAddkc :: Parser Command
parseAddi :: Parser Command
parseAddic :: Parser Command
parseAddik :: Parser Command
parseAddikc :: Parser Command
parseAnd :: Parser Command
parseAndi :: Parser Command
parseAndn :: Parser Command
parseAndni :: Parser Command
parseBsrl :: Parser Command
parseBsra :: Parser Command
parseBsll :: Parser Command
parseBsrli :: Parser Command
parseBsrai :: Parser Command
parseBslli :: Parser Command
parseCmp :: Parser Command
parseCmpu :: Parser Command
parseIdiv :: Parser Command
parseIdivu :: Parser Command
parseLbu :: Parser Command
parseLbui :: Parser Command
parseLhu :: Parser Command
parseLhui :: Parser Command
parseLw :: Parser Command
parseLwi :: Parser Command
parseMul :: Parser Command
parseMuli :: Parser Command
parseOr :: Parser Command
parseOri :: Parser Command
parseRsub :: Parser Command
parseRsubc :: Parser Command
parseRsubk :: Parser Command
parseRsubkc :: Parser Command
parseRsubi :: Parser Command
parseRsubic :: Parser Command
parseRsubik :: Parser Command
parseRsubikc :: Parser Command
parseSb :: Parser Command
parseSbi :: Parser Command
parseSh :: Parser Command
parseShi :: Parser Command
parseSw :: Parser Command
parseSwi :: Parser Command
parseXor :: Parser Command
parseXori :: Parser Command
parseBeq :: Parser Command
parseBeqd :: Parser Command
parseBeqi :: Parser Command
parseBeqid :: Parser Command
parseBge :: Parser Command
parseBged :: Parser Command
parseBgei :: Parser Command
parseBgeid :: Parser Command
parseBgt :: Parser Command
parseBgtd :: Parser Command
parseBgti :: Parser Command
parseBgtid :: Parser Command
parseBle :: Parser Command
parseBled :: Parser Command
parseBlei :: Parser Command
parseBleid :: Parser Command
parseBlt :: Parser Command
parseBltd :: Parser Command
parseBlti :: Parser Command
parseBltid :: Parser Command
parseBne :: Parser Command
parseBned :: Parser Command
parseBnei :: Parser Command
parseBneid :: Parser Command
parseBrld :: Parser Command
parseBrald :: Parser Command
parseBrlid :: Parser Command
parseBralid :: Parser Command
parseBrk :: Parser Command
parseBrki :: Parser Command
parseMfs :: Parser Command
parseMts :: Parser Command
parseRtbd :: Parser Command
parseRtid :: Parser Command
parseRtsd :: Parser Command
parseSextHex :: Parser Command
parseSextOct :: Parser Command
parseSra :: Parser Command
parseSrc :: Parser Command
parseSrl :: Parser Command
parseWic :: Parser Command
parseBr :: Parser Command
parseBra :: Parser Command
parseBrad :: Parser Command
parseBri :: Parser Command
parseBrai :: Parser Command
parseBrid :: Parser Command
parseBraid :: Parser Command
instance GHC.Show.Show ParserMicroBlaze.Imm
instance GHC.Show.Show ParserMicroBlaze.Oper
instance GHC.Show.Show ParserMicroBlaze.Exp
instance GHC.Show.Show ParserMicroBlaze.Op


module REPL


module TestData
